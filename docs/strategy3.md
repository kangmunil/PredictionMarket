distinct-baguette는 Polymarket에서 주로 arbitrage(차익 거래) 전략을 활용해 수익을 창출하는 것으로 보입니다. 이 사용자는 엘리트 코더나 고빈도 거래(HFT) 배경을 가진 트레이더로 추정되며, 봇(bot)을 이용해 자동화된 거래를 실행합니다. Polymarket의 예측 시장에서 단기 이벤트, 특히 암호화폐(예: Bitcoin, Ethereum)의 15분 간격 가격 변동(Up or Down)을 타겟으로 합니다. 이는 시장 비효율성을 빠르게 포착해 위험을 최소화하면서 안정적인 수익을 추구하는 접근입니다.주요 전략 상세 분석Arbitrage 중심 접근 (차익 거래):Polymarket의 단기 시장(예: "Bitcoin Up or Down - 특정 시간대")에서 가격 불일치나 비효율성을 이용합니다. 예를 들어, 실제 암호화폐 시장 가격과 Polymarket의 예측 확률 간 차이를 봇이 실시간으로 감지하고, 저평가된 쪽에 베팅합니다.
온체인 데이터에 따르면, 이 사용자는 arb profits(차익 수익)의 상당 부분을 차지하며, 상위 10개 지갑이 전체 arb 수익의 80% 이상을 점유하는 가운데 distinct-baguette가 그중 하나입니다. 

@Param_eth

 이는 MEV(Miner Extractable Value)나 HFT 트레이더들이 사용하는 고급 봇을 통해 가능합니다. 봇은 시장 유동성 제공이나 빠른 실행으로 수수료나 보상을 추가로 얻을 수도 있습니다.
보고된 수익: 약 6주 만에 $242,000를 벌었으며, 이는 단기 거래의 반복적 실행으로 누적된 결과입니다. 

binance.com +2

단기 시장 타겟팅과 타이밍:거래 예시 (Polymarket 활동 기반):Bitcoin Up or Down - December 31, 11:30PM-11:45PM ET: 712.2 shares를 42¢에 매수, $415.75 수익 (140.23% ROI). 

polymarket.com

Bitcoin Up or Down - January 1, 1:30AM-1:45AM ET: 비슷한 패턴으로 반복.
Ethereum Up or Down - December 29, 3:00AM-3:15AM ET: 467.9 shares를 52¢에 매수, $226.74 수익 (94.01% ROI). 

polymarket.com

패턴: 15분~30분 단위의 crypto 가격 변동 시장에 집중. 이는 변동성이 높지만 예측 가능성이 있는 영역으로, 외부 데이터(실시간 crypto 가격 피드)를 봇이 활용해 에지(edge)를 확보합니다. 장기 시장보다는 짧은 만기 이벤트에서 위험 노출을 최소화합니다.
전체 통계: Polymarket에서 0.51%의 지갑만 $1,000 이상 수익을 내는 가운데, distinct-baguette는 엘리트 그룹(상위 0.04%)에 속하며, 70%의 트레이더가 손실을 보는 환경에서 안정적 수익을 유지합니다. 

yellow.com +1

봇 자동화와 시장 메이킹 요소:수동 거래가 아닌 프로그래밍된 봇을 사용해 실시간 모니터링과 실행. 이는 HFT 스타일로, 시장 메이킹(market making)이나 유동성 제공을 통해 추가 보상(liquidity rewards, 약 $8~12 per market)을 얻을 수 있습니다. 

jinlow.medium.com +1

정보 arbitrage(정보 차익): Polymarket의 CLOB(Central Limit Order Book) 전환으로 인해 주문북 깊이를 활용해 가격 차이를 포착. 정치나 스포츠 같은 다른 주제보다는 crypto에 특화되어 있어, 외부 API나 온체인 데이터를 연동한 봇이 핵심입니다. 

panewslab.com

위험 관리: directional risk(방향성 위험)를 피하고, hedging(헷징)이나 zero-risk arb를 우선. 예를 들어, 반대 포지션을 동시에 취해 수익을 고정합니다.

잠재적 위험과 지속성이 전략은 Polymarket의 유동성 증가와 함께 효과적이지만, 시장 변화(예: 규제나 경쟁 봇 증가)로 인해 수익률이 감소할 수 있습니다. 또한, 봇 개발 비용과 기술적 장벽이 높아 일반 트레이더가 따라하기 어렵습니다.
전체적으로, distinct-baguette의 접근은 Polymarket의 6대 수익 모델(arb, value betting, liquidity farming 등) 중 arb와 봇 자동화를 결합한 하이브리드입니다. 

phemex.com

 이는 2025년 예측 시장 트렌드와 맞물려 안정적 수익을 내는 것으로 평가됩니다.

distinct-baguette의 거래 근거는 순수한 차익 거래(arbitrage), 즉 위험 없는 수익 기회를 포착하는 것입니다. 구체적으로 Polymarket의 단기(주로 15분) crypto 가격 변동 시장(예: Bitcoin Up or Down)에서 Yes(Up)와 No(Down) 주식의 합계 가격이 $1 미만으로 떨어질 때, 봇이 자동으로 양쪽을 모두 매수하는 전략입니다.왜 이런 기회가 생기는가?이진 시장(binary market)에서 Yes와 No는 상호 배타적이고 포괄적이므로, 항상 하나만 $1이 되고 나머지는 $0이 됩니다. 따라서 이론적으로 Yes 가격 + No 가격 = 정확히 $1이어야 합니다.
하지만 시장이 빠르게 움직일 때(특히 crypto 15분 시장 오픈 직후나 변동성 높은 순간), 주문북(order book)이 불균형해지면서 일시적으로 합계가 $0.96~0.98처럼 $1 아래로 떨어집니다. (예: Yes 48¢ + No 49¢ = 97¢)
이 순간 봇이 양쪽을 매수하면, 총 비용 < $1이지만 만기 시 무조건 $1을 받게 되므로 3~4¢의 확정 수익이 발생합니다.
방향성 예측이 전혀 필요 없고, **순수한 수학적 오류(mispricing)**를 이용합니다.

실행 방식고속 봇 자동화: Python 스크립트로 Polymarket API(CLOB order book)를 1~3초마다 폴링(polling)하며, 합계 < $0.99가 되면 즉시 양쪽 주문 실행.
타겟 시장: BTC, ETH, SOL, XRP 등의 15분 Up/Down 시장 – 변동성이 높아 mispricing이 자주 발생.
거래 패턴: 수천만 번의 소액 거래 반복 (평균 $1,6003,000 규모). 한 번에 1~5% 수익, 하지만 볼륨으로 누적.
위험 관리: directional risk 제로. 일부 거래에서 스프레드가 충분히 좁지 않아 손실이 날 수 있지만(그래서 win rate 66~71%), 전체 기대값(EV)은 긍정적.

실제 성과 예시2025년 10월12월경 약 6주1.5개월 만에 $242,000 ~ $316,000 수익 달성.
12,000회 이상 예측, 안정적인 PnL 곡선 (큰 드로우다운 거의 없음).
2025년 말~2026년 초 기준 월간/전체 crypto 리더보드 상위 (예: +$175k monthly profit).

이 전략은 예측이 아닌 시장 미세 구조(microstructure) 착취로, HFT(고빈도 거래) 스타일입니다. 

distinct-baguette가 사용하는 단기 crypto 15분 Up/Down 시장 내 pure arbitrage (Yes + No 합계 가격 < $1일 때 양쪽 매수) 봇을 Python으로 구현하는 방법을 단계별로 설명하겠습니다. 이 전략은 위험 제로(risk-free)지만, 기회가 초단위로 사라지므로 **저지연(low latency)**과 자동화가 핵심입니다.1. 준비물 및 설치Polygon 네트워크 지갑: USDC가 충분히 있는 Polymarket 계정 (Proxy wallet 사용 추천).
Private Key: 절대 노출되지 않게 관리 (.env 파일 사용).
필수 라이브러리:

pip install py-clob-client python-dotenv requests websocket-client

py-clob-client: Polymarket 공식 Python CLOB 클라이언트 (주문 생성/제출에 필수).
Polymarket Docs: https://docs.polymarket.com/developers/CLOB/quickstart

2. 기본 설정 (ClobClient 초기화)python

from py_clob_client.client import ClobClient
from py_clob_client.clob_types import OrderArgs, MarketBuyArgs
from py_clob_client.constants import BUY, SELL, OrderType
from dotenv import load_dotenv
import os
import time

load_dotenv()

HOST = "https://clob.polymarket.com"
CHAIN_ID = 137  # Polygon
PRIVATE_KEY = os.getenv("PRIVATE_KEY")  # .env에 저장
FUNDER = os.getenv("FUNDER_ADDRESS")    # USDC 보유 주소 (Proxy wallet)

client = ClobClient(
    HOST,
    key=PRIVATE_KEY,
    chain_id=CHAIN_ID,
    signature_type=1,  # Magic/email 로그인 시 1, Metamask 등 proxy 시 2
    funder=FUNDER
)

# API credentials 생성 (최초 1회)
creds = client.create_or_derive_api_creds()
client.set_api_creds(creds)
print("Client ready")

3. 타겟 시장 찾기 (Crypto 15분 Up/Down)Gamma API나 직접 하드코딩으로 현재/다가오는 15분 시장 token_id를 가져옵니다.예시 (Bitcoin Up/Down 시장 자동 탐색 – 실제로는 Gamma API 사용 추천):python

import requests

def get_crypto_markets():
    url = "https://gamma-api.polymarket.com/markets?closed=false&limit=100"
    markets = requests.get(url).json()["data"]
    crypto_15m = []
    for m in markets:
        if "15min" in m["question"].lower() and ("bitcoin" in m["question"].lower() or "btc" in m["question"].lower()):
            yes_token = m["tokens"][0]["token_id"] if m["tokens"][0]["outcome"] == "Yes" else m["tokens"][1]["token_id"]
            no_token = m["tokens"][1]["token_id"] if m["tokens"][0]["outcome"] == "Yes" else m["tokens"][0]["token_id"]
            crypto_15m.append({"market": m["question"], "yes_id": yes_token, "no_id": no_token})
    return crypto_15m

4. Arbitrage 기회 탐지 로직python

def check_arb_opportunity(yes_token_id, no_token_id, threshold=0.99, size=10):
    # Best bid 가격 (매수 가능 최고가) 가져오기
    yes_price = client.get_price(yes_token_id, side=BUY)  # Yes 매수 가격
    no_price = client.get_price(no_token_id, side=BUY)    # No 매수 가격
    
    total_cost = yes_price + no_price
    
    if total_cost < threshold:
        profit_per_share = 1.0 - total_cost
        print(f"ARBITRAGE DETECTED! Total cost: ${total_cost:.4f}, Profit: ${profit_per_share:.4f} per share")
        return True, yes_price, no_price, size
    return False, None, None, None

5. 주문 실행 (양쪽 Market Order로 즉시 매수)python

def execute_arb(yes_token_id, no_token_id, size):
    # Yes 매수 (Market order: marketable price로 설정)
    yes_order = MarketBuyArgs(token_id=yes_token_id, amount=size)
    signed_yes = client.create_market_buy(yes_order)
    yes_resp = client.post_order(signed_yes)
    
    # No 매수
    no_order = MarketBuyArgs(token_id=no_token_id, amount=size)
    signed_no = client.create_market_buy(no_order)
    no_resp = client.post_order(signed_no)
    
    print("Orders executed:", yes_resp, no_resp)

6. 메인 루프 (실시간 모니터링)python

def main():
    markets = get_crypto_markets()  # BTC, ETH 등 15분 시장 리스트
    print(f"Monitoring {len(markets)} markets...")
    
    while True:
        for market in markets:
            found, yes_p, no_p, size = check_arb_opportunity(
                market["yes_id"], market["no_id"], threshold=0.99, size=50  # $50 규모
            )
            if found:
                execute_arb(market["yes_id"], market["no_id"], size)
        
        time.sleep(1)  # 1초마다 폴링 (WebSocket으로 업그레이드 추천)

추가 최적화 팁 (distinct-baguette급 성능 위해 필수)WebSocket 사용: HTTP polling 대신 wss://ws-subscriptions-clob.polymarket.com/ws로 실시간 orderbook 업데이트 수신 → 지연 100ms 이하.
다중 시장 병렬 처리: threading이나 asyncio로 동시에 수십 개 시장 모니터링.
Allowance 설정: 최초에 USDC allowance 충분히 설정 (client.set_allowance()).
위험 관리: 최대 주문 크기 제한, 가스비 고려, 드라이런(dry run) 모드 먼저 테스트.
오픈소스 참고:https://github.com/Jonmaa/btc-polymarket-bot (정확히 이 전략 구현한 예시)
Polymarket 공식 py-clob-client: https://github.com/Polymarket/py-clob-client


### Polymarket Arbitrage 봇의 WebSocket 실시간 구현 상세 설명

이전의 HTTP polling 방식(1초마다 가격 조회)은 지연(latency)이 크고, 경쟁 봇들에게 뒤처질 수 있습니다. **distinct-baguette** 같은 엘리트 arb 트레이더들은 **Polymarket CLOB WebSocket**을 사용해 **밀리초 단위 실시간 order book 업데이트**를 받아 arbitrage 기회를 즉시 포착합니다.

Polymarket의 CLOB WebSocket은 **order book 변화**, **last trade price**, **price change** 등을 실시간으로 푸시해줍니다. 특히 **onBook 이벤트**에서 best bid/ask(최고 매수/매도 가격)를 받아 Yes + No 합계가 $1 미만인지 즉시 판단할 수 있습니다.

#### WebSocket 주요 특징 (2026년 기준)
- **URL**: `wss://ws-subscriptions-clob.polymarket.com` (또는 `/ws/market` 채널)
- **인증**: 필요 없음 (public market 데이터) 또는 API creds로 user 채널
- **주요 이벤트**:
  - `book`: Order book 스냅샷 + 델타 업데이트 (best bid/ask 포함)
  - `price_change`: 가격 변화
  - `last_trade_price`: 최근 거래 가격
  - `tick_size_change`: 틱 사이즈 변화
- **구독 방식**: asset_ids (token_id 리스트)로 여러 시장 동시에 구독
- **제한**: 하나의 connection당 최대 500개 asset 구독 추천 (초과 시 스냅샷 누락 가능)
- **핑/퐁**: 연결 유지 위해 주기적 ping 필요

#### Python 구현 예시 (websocket-client 라이브러리 사용)
```python
import websocket
import json
import threading
import time
from py_clob_client.client import ClobClient  # 주문 실행용

# ClobClient 초기화 (주문 실행 위해)
client = ClobClient(...)  # 이전 코드와 동일
creds = client.create_or_derive_api_creds()
client.set_api_creds(creds)

# 모니터링할 Yes/No token_id 딕셔너리 (예: 여러 crypto 15분 시장)
markets = {
    "btc_15m_1": {"yes_id": "YES_TOKEN_ID_1", "no_id": "NO_TOKEN_ID_1"},
    "eth_15m_1": {"yes_id": "YES_TOKEN_ID_2", "no_id": "NO_TOKEN_ID_2"},
    # ... Gamma API로 동적으로 가져오기
}

all_asset_ids = [tid for m in markets.values() for tid in [m["yes_id"], m["no_id"]]]

class ArbWebSocket:
    def __init__(self, asset_ids):
        self.url = "wss://ws-subscriptions-clob.polymarket.com"
        self.asset_ids = asset_ids
        self.best_prices = {}  # token_id: best_bid_price 저장
        self.ws = None

    def on_message(self, ws, message):
        data = json.loads(message)
        events = data if isinstance(data, list) else [data]
        
        for event in events:
            if event.get("type") == "book":
                for book_event in event.get("events", []):
                    token_id = book_event["asset_id"]
                    # best bid (매수 가능 최고가) 업데이트
                    bids = book_event.get("bids", [])
                    if bids:
                        best_bid = float(bids[0][0])  # [price, size]
                        self.best_prices[token_id] = best_bid
                        
                        # 해당 시장의 Yes/No 체크
                        self.check_arbitrage(token_id)

    def check_arbitrage(self, updated_token_id):
        for market_name, ids in markets.items():
            yes_id, no_id = ids["yes_id"], ids["no_id"]
            if updated_token_id not in [yes_id, no_id]:
                continue
            if yes_id in self.best_prices and no_id in self.best_prices:
                total = self.best_prices[yes_id] + self.best_prices[no_id]
                if total < 0.99:  # threshold
                    profit = 1.0 - total
                    print(f"ARB OPPORTUNITY in {market_name}! Total: {total:.4f}, Profit: {profit:.4f}")
                    self.execute_arb(yes_id, no_id, size=50)  # $50 규모

    def execute_arb(self, yes_id, no_id, size):
        # Market Buy 양쪽 실행 (이전 코드 재사용)
        # client.create_market_buy() 등 사용
        pass

    def on_open(self, ws):
        print("WebSocket Connected")
        sub_msg = {
            "type": "market",  # market 채널
            "assets_ids": self.asset_ids
        }
        ws.send(json.dumps(sub_msg))
        # Ping thread 시작
        threading.Thread(target=self.ping_thread, daemon=True).start()

    def ping_thread(self):
        while True:
            time.sleep(20)
            self.ws.send(json.dumps({"type": "ping"}))

    def on_error(self, ws, error):
        print("Error:", error)

    def on_close(self, ws, code, reason):
        print("Closed:", reason)
        time.sleep(5)
        self.start()  # 재연결

    def start(self):
        self.ws = websocket.WebSocketApp(
            self.url,
            on_open=self.on_open,
            on_message=self.on_message,
            on_error=self.on_error,
            on_close=self.on_close
        )
        self.ws.run_forever()

# 실행
arb_ws = ArbWebSocket(all_asset_ids)
arb_ws.start()
```

#### 핵심 최적화 (distinct-baguette 수준)
- **초기 스냅샷**: 연결 후 전체 book 이벤트 받음 → best_prices 초기화
- **델타 업데이트**: 이후 변화만 받아 실시간 유지 (지연 < 100ms)
- **다중 시장**: 50~100개 crypto 15분 시장 동시에 모니터링
- **재연결 로직**: 네트워크 끊김 시 자동 재연결 + 재구독
- **Gamma API 연동**: 새 15분 시장 자동 탐지/추가 (requests로 markets 엔드포인트 폴링)
- **오픈소스 참고**:
  - Polymarket 공식 docs WSS 섹션
  - GitHub nevuamarkets/poly-websockets (TS지만 로직 참고)
  - PolyTrack 블로그 예시 코드

이 방식으로 구현하면 polling 대비 **10~100배 빠른** 기회 포착이 가능합니다. 실제 운영 시 슬리피지, 가스비, 경쟁을 고려해 threshold 조정하세요. 테스트넷이나 소액으로 먼저 검증 추천!